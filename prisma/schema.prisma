datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum Role {
  USER
  ADMIN
}

model User {
  id        String   @id @default(uuid()) @db.Uuid
  email     String   @unique
  password  String
  name      String?
  surname   String?
  role      Role     @default(USER)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  platformsCreated Platform[] @relation("UserCreatedPlatforms")

  // Opposite relation (Subscription.user)
  subscriptions       Subscription[]
  passwordResetTokens PasswordResetToken[]
}

enum PlatformStatus {
  ACTIVE
  INACTIVE
}

model Platform {
  id          String         @id @default(uuid()) @db.Uuid
  name        String
  slug        String         @unique
  description String?
  websiteUrl  String?
  logoUrl     String?
  status      PlatformStatus @default(ACTIVE)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  createdById String? @db.Uuid
  createdBy   User?   @relation("UserCreatedPlatforms", fields: [createdById], references: [id], onDelete: SetNull)

  fields PlatformField[]

  // ✅ New: Platform plans (planName yerine planId ilişkisi)
  plans PlatformPlan[]

  subscriptions Subscription[]

  @@index([status])
  @@index([createdAt])
}

model PlatformPlan {
  id String @id @default(uuid()) @db.Uuid

  platformId String   @db.Uuid
  platform   Platform @relation(fields: [platformId], references: [id], onDelete: Cascade)

  name     String
  order    Int     @default(0)
  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Opposite relation (Subscription.plan)
  subscriptions Subscription[]

  @@unique([platformId, name])
  @@index([platformId])
  @@index([order])
  @@index([isActive])
}

enum PlatformFieldType {
  TEXT
  NUMBER
  EMAIL
  PASSWORD
  SELECT
  MULTISELECT
  CHECKBOX
  TEXTAREA
  DATE
}

model PlatformField {
  id String @id @default(uuid()) @db.Uuid

  platformId String   @db.Uuid
  platform   Platform @relation(fields: [platformId], references: [id], onDelete: Cascade)

  key      String
  label    String
  type     PlatformFieldType
  required Boolean           @default(false)

  optionsJson Json?
  order       Int   @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Opposite relation (SubscriptionFieldValue.platformField)
  subscriptionValues SubscriptionFieldValue[]

  @@unique([platformId, key])
  @@index([platformId])
  @@index([order])
}

enum SubscriptionStatus {
  ACTIVE
  PAUSED
  CANCELED
}

enum RepeatUnit {
  WEEK
  MONTH
  YEAR
}

model Subscription {
  id String @id @default(uuid()) @db.Uuid

  platformId String   @db.Uuid
  platform   Platform @relation(fields: [platformId], references: [id], onDelete: Cascade)

  userId String @db.Uuid
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // ✅ status + status changed time
  status          SubscriptionStatus @default(ACTIVE)
  statusChangedAt DateTime?

  // ✅ repeat system
  repeatUnit     RepeatUnit @default(MONTH)
  repeatInterval Int        @default(1)

  // ✅ standard dates
  startDate DateTime
  endDate   DateTime?

  // ✅ standard money
  amount   Decimal? @db.Decimal(10, 2)
  currency String?

  // ✅ plan: platformda plan varsa backend zorunlu yapacak
  planId String?       @db.Uuid
  plan   PlatformPlan? @relation(fields: [planId], references: [id], onDelete: SetNull)

  // ✅ standard account/contact/notes
  accountEmail String?
  accountPhone String?
  notes        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  values SubscriptionFieldValue[]

  @@index([userId])
  @@index([platformId])
  @@index([status])
  @@index([statusChangedAt])
  @@index([repeatUnit])
  @@index([startDate])
  @@index([planId])
}

model SubscriptionFieldValue {
  id String @id @default(uuid()) @db.Uuid

  subscriptionId String       @db.Uuid
  subscription   Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  platformFieldId String        @db.Uuid
  platformField   PlatformField @relation(fields: [platformFieldId], references: [id], onDelete: Cascade)

  valueJson Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([subscriptionId, platformFieldId])
  @@index([subscriptionId])
  @@index([platformFieldId])
}

model PasswordResetToken {
  id        String    @id @default(uuid()) @db.Uuid
  userId    String    @db.Uuid
  tokenHash String    @unique
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
}
